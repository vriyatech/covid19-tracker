{"ast":null,"code":"import { getDataFromRegion, metricText, parseDate, simplifyName } from './utils';\nimport * as str from './strings';\nimport { plotSpecificTypes } from './plot_types';\nimport i18n from '../data/i18n.yml';\nimport diseases from '../data/other_diseases_stats.yml';\nexport const generatePlotData = params => generatePlotDataFunc[params.plotSpecificType](params);\nconst metricColors = {\n  confirmedCount: 'var(--primary-color-4)',\n  deadCount: 'var(--primary-color-10)',\n  curedCount: 'var(--primary-color-2)'\n};\nconst metricColorsDark = {\n  confirmedCount: 'var(--primary-color-4)',\n  deadCount: 'var(--lighter-grey)',\n  curedCount: 'var(--primary-color-2)'\n};\n\nconst generatePlotDataTotal = ({\n  data,\n  date,\n  currentRegion,\n  lang,\n  darkMode,\n  playing,\n  scale,\n  plotSpecificType,\n  plotDetails,\n  plotDates,\n  fullPlot\n}, fullData = false) => {\n  let maxValue = 0;\n  let minValue = 100000;\n  let plotData = ['deadCount', 'curedCount', 'confirmedCount'].map(metric => {\n    const counts = getDataFromRegion(data, currentRegion)[metric];\n    return {\n      id: metricText[metric][lang],\n      color: darkMode ? metricColorsDark[metric] : metricColors[metric],\n      data: Object.keys(counts).sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n        if (counts[d] > maxValue) maxValue = counts[d];\n        if (counts[d] < minValue) minValue = counts[d];\n        return scale === 'linear' || counts[d] > 0 ? {\n          x: d,\n          y: counts[d]\n        } : null;\n      }).filter(x => x != null)\n    };\n  });\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  if (!fullData) plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData,\n    ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue)\n  };\n};\n\nconst generatePlotDataNew = (params, fullData = false) => {\n  let {\n    plotData\n  } = generatePlotDataTotal(params, true);\n  plotData = convertTotalToNew(plotData);\n  if (!fullData) plotData = applyDateRange(plotData, params.plotDates);\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataGrowthRate = params => {\n  let {\n    plotData\n  } = params.plotSpecificType === 'growth_total' ? generatePlotDataTotal(params, true) : generatePlotDataNew(params, true);\n  const metric = params.metric;\n  plotData.forEach(metricData => {\n    metricData.data = metricData.data.reduce((s, v, i) => [...s, metricData.data[i - 1] && metricData.data[i - 1].y > 0 ? { ...v,\n      y: (v.y - metricData.data[i - 1].y) / metricData.data[i - 1].y\n    } : { ...v,\n      y: 0\n    }], []);\n  });\n  if (metric === 'confirmedCount') plotData = [plotData[2]];\n  if (metric === 'curedCount') plotData = [plotData[1]];\n  if (metric === 'deadCount') plotData = [plotData[0]];\n  plotData = applyDateRange(plotData, params.plotDates);\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataRate = ({\n  data,\n  currentRegion,\n  darkMode,\n  lang,\n  date,\n  playing,\n  plotDetails,\n  plotDates\n}) => {\n  const confirmedCounts = getDataFromRegion(data, currentRegion)['confirmedCount'];\n  const metrics = plotDetails.recoveryRate === 'show' ? ['deadCount', 'curedCount'] : ['deadCount'];\n  let plotData = metrics.map(metric => {\n    const counts = getDataFromRegion(data, currentRegion)[metric];\n    const newMetric = metric === 'deadCount' ? 'fatalityRate' : 'recoveryRate';\n    return {\n      id: metricText[newMetric][lang],\n      color: darkMode ? metricColorsDark[metric] : metricColors[metric],\n      data: Object.keys(counts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => ({\n        d,\n        count: confirmedCounts[d] > 0 ? counts[d] / confirmedCounts[d] : 0\n      })).map(({\n        d,\n        count\n      }) => {\n        return {\n          x: d,\n          y: count\n        };\n      })\n    };\n  });\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataOneVsRest = ({\n  data,\n  currentRegion,\n  metric,\n  lang,\n  date,\n  playing,\n  scale,\n  plotSpecificType,\n  plotDetails,\n  plotDates,\n  fullPlot\n}) => {\n  let maxValue = 0;\n  let minValue = 100000;\n  const currentData = getDataFromRegion(data, currentRegion);\n  const counts = currentData[metric];\n  let regionName = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH;\n  regionName = simplifyName(regionName, lang);\n  const parentRegion = currentRegion.length === 1 ? [str.GLOBAL_ZH] : currentRegion.slice(0, currentRegion.length - 1);\n  const parentData = getDataFromRegion(data, parentRegion);\n  const parentCounts = parentData[metric];\n  let parentRegionName = lang === 'zh' ? parentRegion[parentRegion.length - 1] : parentData.ENGLISH;\n  parentRegionName = simplifyName(parentRegionName, lang);\n  let plotData = [];\n  const parentPlotData = {\n    id: lang === 'zh' ? `${parentRegionName} (${i18n.REST[lang]})` : `${i18n.REST[lang]} of ${parentRegionName}`,\n    color: 'var(--primary-color-4)',\n    data: Object.keys(parentCounts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n      if (counts[d] == null) return null;\n      if (parentCounts[d] - counts[d] > maxValue) maxValue = parentCounts[d] - counts[d];\n      if (parentCounts[d] - counts[d] < minValue) minValue = parentCounts[d] - counts[d];\n      return scale === 'linear' || parentCounts[d] - counts[d] > 0 ? {\n        x: d,\n        y: parentCounts[d] - counts[d]\n      } : null;\n    }).filter(x => x != null)\n  };\n  const currentPlotData = {\n    id: regionName,\n    color: 'var(--primary-color-2)',\n    data: Object.keys(counts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n      if (parentCounts[d] == null) return null;\n      if (counts[d] > maxValue) maxValue = counts[d];\n      if (counts[d] < minValue) minValue = counts[d];\n      return scale === 'linear' || counts[d] > 0 ? {\n        x: d,\n        y: counts[d]\n      } : null;\n    }).filter(x => x != null)\n  };\n  plotData.push(parentPlotData);\n  plotData.push(currentPlotData);\n\n  if (plotSpecificType === 'one_vs_rest_new') {\n    plotData = convertTotalToNew(plotData);\n  }\n\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData,\n    ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue)\n  };\n};\n\nconst generatePlotDataSubregionRankings = ({\n  data,\n  currentRegion,\n  metric,\n  lang,\n  darkMode,\n  playing,\n  date,\n  plotDates,\n  plotSpecificType\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  const subregions = playing ? getSubregions(data, currentRegion, metric, 10) : getSubregions(data, currentRegion, metric, 10, date);\n  let regionIndices = {};\n  let dates = [];\n  let plotData = subregions.map((region, i) => {\n    dates = [...dates, ...Object.keys(currentData[region][metric])];\n    dates = [...new Set(dates)];\n    regionIndices[region] = i;\n    return region;\n  }).map((region, i) => {\n    const id = lang === 'zh' ? region : currentData[region].ENGLISH;\n    const dd = Object.keys(currentData[region][metric]).sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1).filter(d => parseDate(d) <= parseDate(date)).filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]));\n    const counts = dd.map(d => currentData[region][metric][d]);\n    let count = counts[counts.length - 1];\n    if (plotSpecificType === 'most_affected_subregions_new') count = counts.length >= 2 ? counts[counts.length - 1] - counts[counts.length - 2] : counts[counts.length - 1];\n    return {\n      id: simplifyName(id, lang),\n      fullId: id,\n      name: region,\n      color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\n      count,\n      data: []\n    };\n  });\n  dates = dates.sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1);\n  let regionSkipped = {};\n  dates.filter(d => parseDate(d) <= parseDate(date)).filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0])).forEach((d, i) => {\n    let regionCounts = [];\n    plotData.forEach(region => {\n      let counts = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0;\n\n      if (plotSpecificType === 'most_affected_subregions_new') {\n        if (i > 0 && currentData[region.name][metric][dates[i - 1]]) counts = counts - currentData[region.name][metric][dates[i - 1]];\n      }\n\n      regionCounts.push({\n        region: region.name,\n        counts\n      });\n    });\n    regionCounts = regionCounts.sort((a, b) => a.counts <= b.counts ? 1 : -1);\n    regionCounts.forEach((region, i) => {\n      if (region.counts === 0 && regionSkipped[region.region] == null) {\n        plotData[regionIndices[region.region]].data.push({\n          x: d,\n          y: null\n        });\n      } else {\n        regionSkipped[region.region] = true;\n        plotData[regionIndices[region.region]].data.push({\n          x: d,\n          y: i + 1\n        });\n      }\n    });\n  });\n  return {\n    plotData,\n    dates\n  };\n};\n\nconst generatePlotDataSubregionStream = ({\n  data,\n  currentRegion,\n  lang,\n  playing,\n  date,\n  plotDates,\n  metric,\n  plotSpecificType,\n  fullPlot\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  let dates = [];\n  let plotData = [];\n  const sortBy = plotSpecificType === 'subregion_active_stream' ? 'confirmedCount' : metric;\n  const numOfRegions = !fullPlot ? 5 : 9;\n  let subregionsData = getSubregions(data, currentRegion, sortBy, numOfRegions).map(region => {\n    dates = [...dates, ...Object.keys(currentData[region]['confirmedCount'])];\n    dates = [...new Set(dates)];\n    return region;\n  }).map(region => {\n    const id = lang === 'zh' ? region : currentData[region].ENGLISH;\n    return {\n      id: simplifyName(id, lang),\n      fullId: id,\n      name: region\n    };\n  });\n  let plotKeys = subregionsData.map(x => x.id); // at least (numOfRegions + 1) subregions\n\n  if (Object.keys(currentData).length >= numOfRegions + 5) plotKeys = [...plotKeys, i18n.OTHERS[lang]];\n  plotKeys = plotKeys.reverse();\n  dates = dates.sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1);\n  dates = dates.filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0])); // no subregions\n\n  if (subregionsData.length === 0) {\n    dates = Object.keys(currentData['confirmedCount']).sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1);\n    let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH;\n    id = simplifyName(id, lang);\n    plotKeys = [id];\n  }\n\n  dates.filter(d => !playing || parseDate(d) <= parseDate(date)).forEach((d, i) => {\n    let subregionCounts = {};\n    subregionsData.forEach(region => {\n      if (plotSpecificType === 'subregion_active_stream') {\n        const confirmedCount = currentData[region.name]['confirmedCount'][d] ? currentData[region.name]['confirmedCount'][d] : 0;\n        const deadCount = currentData[region.name]['deadCount'][d] ? currentData[region.name]['deadCount'][d] : 0;\n        const curedCount = currentData[region.name]['curedCount'][d] ? currentData[region.name]['curedCount'][d] : 0;\n        const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0);\n        subregionCounts[region.id] = remainingConfirmed;\n      } else {\n        let count = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0;\n        if (plotSpecificType === 'subregion_new_stream' && currentData[region.name][metric][dates[i - 1]]) count -= currentData[region.name][metric][dates[i - 1]];\n        subregionCounts[region.id] = count;\n      }\n    });\n    let otherConfirmedCount = 0;\n    let otherDeadCount = 0;\n    let otherCuredCount = 0; // compute number of remaining confirmed cases from non-top-5 subregions\n\n    Object.keys(currentData).filter(region => !['confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH].includes(region)).filter(region => !subregionsData.map(x => x.name).includes(region)).forEach(region => {\n      const confirmedCount = currentData[region]['confirmedCount'][d] ? currentData[region]['confirmedCount'][d] : 0;\n      const deadCount = currentData[region]['deadCount'][d] ? currentData[region]['deadCount'][d] : 0;\n      const curedCount = currentData[region]['curedCount'][d] ? currentData[region]['curedCount'][d] : 0;\n      otherConfirmedCount += confirmedCount;\n      otherDeadCount += deadCount;\n      otherCuredCount += curedCount;\n\n      if (plotSpecificType === 'subregion_new_stream') {\n        const confirmedCountPrevious = currentData[region]['confirmedCount'][dates[i - 1]] ? currentData[region]['confirmedCount'][dates[i - 1]] : 0;\n        const deadCountPrevious = currentData[region]['deadCount'][dates[i - 1]] ? currentData[region]['deadCount'][dates[i - 1]] : 0;\n        const curedCountPrevious = currentData[region]['curedCount'][dates[i - 1]] ? currentData[region]['curedCount'][dates[i - 1]] : 0;\n        otherConfirmedCount -= confirmedCountPrevious;\n        otherDeadCount -= deadCountPrevious;\n        otherCuredCount -= curedCountPrevious;\n      }\n    });\n    let otherCount = 0;\n    if (metric === 'confirmedCount') otherCount = Math.max(otherConfirmedCount, 0);\n    if (metric === 'deadCount') otherCount = Math.max(otherDeadCount, 0);\n    if (metric === 'curedCount') otherCount = Math.max(otherCuredCount, 0);\n    if (plotSpecificType === 'subregion_active_stream') otherCount = Math.max(otherConfirmedCount - otherDeadCount - otherCuredCount, 0);\n    if (Object.keys(currentData).length >= 10) subregionCounts[i18n.OTHERS[lang]] = otherCount; // no subregions\n\n    if (subregionsData.length === 0) {\n      const confirmedCount = currentData['confirmedCount'][d] ? currentData['confirmedCount'][d] : 0;\n      const deadCount = currentData['deadCount'][d] ? currentData['deadCount'][d] : 0;\n      const curedCount = currentData['curedCount'][d] ? currentData['curedCount'][d] : 0;\n      const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0);\n      let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH;\n      id = simplifyName(id, lang);\n      subregionCounts[id] = plotSpecificType === 'subregion_active_stream' ? remainingConfirmed : Math.max(currentData[metric][d] ? currentData[metric][d] : 0, 0);\n    }\n\n    plotData.push(subregionCounts);\n  });\n  return {\n    plotData,\n    dates,\n    plotKeys\n  };\n};\n\nconst generatePlotDataFatalityLine = ({\n  data,\n  currentRegion,\n  date,\n  darkMode,\n  lang,\n  plotSpecificType,\n  plotDates\n}) => {\n  const confirmedCount = getDataFromRegion(data, currentRegion)['confirmedCount'];\n  const deadCount = getDataFromRegion(data, currentRegion)['deadCount'];\n  const plotData = [{\n    id: 'fatality-line',\n    color: darkMode ? 'var(--primary-color-2)' : 'var(--primary-color-5)',\n    data: Object.keys(confirmedCount).filter(d => parseDate(d) <= parseDate(date) && confirmedCount[d] > 0 && (deadCount[d] > 0 || plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line_only')).filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0])).map(d => ({\n      d,\n      cfr: deadCount[d] != null ? deadCount[d] / confirmedCount[d] : 0\n    })).map(({\n      d,\n      cfr\n    }) => {\n      return {\n        x: confirmedCount[d],\n        y: plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line_only' ? cfr : deadCount[d],\n        date: d,\n        lang\n      };\n    })\n  }];\n  if (plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line2') Object.keys(diseases).forEach(x => {\n    plotData.push({\n      id: x,\n      color: 'var(--light-grey)',\n      data: [{\n        x: diseases[x].confirmedCount,\n        y: plotSpecificType === 'fatality_line' ? diseases[x].deadCount / diseases[x].confirmedCount : diseases[x].deadCount,\n        lang,\n        name: diseases[x][lang],\n        years: diseases[x].years\n      }]\n    });\n  });\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataSubregionFatality = ({\n  data,\n  currentRegion,\n  date,\n  lang,\n  darkMode,\n  plotSpecificType\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  let plotData = [];\n  let maxValue = 0;\n  let minValue = 100000;\n  getSubregions(data, currentRegion).reverse().filter(region => currentData[region]['confirmedCount'][date] > 0 && currentData[region]['deadCount'][date] >= 0 && (currentData[region]['deadCount'][date] > 0 || plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality_only')).forEach((region, i) => {\n    const confirmedCount = currentData[region].confirmedCount[date];\n    const deadCount = currentData[region].deadCount[date];\n    maxValue = Math.max(maxValue, confirmedCount);\n    minValue = Math.min(minValue, confirmedCount);\n    plotData.push({\n      id: region,\n      color: darkMode ? 'rgba(222,73,104,0.6)' : 'rgba(183,55,121,0.5)',\n      data: [{\n        x: confirmedCount,\n        y: plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality_only' ? deadCount / confirmedCount : deadCount,\n        regionName: lang === 'zh' ? region : currentData[region].ENGLISH,\n        lang\n      }]\n    });\n  });\n  if (plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality2') Object.keys(diseases).forEach(x => {\n    plotData.push({\n      id: x,\n      color: 'rgba(0,0,0,0)',\n      data: [{\n        x: diseases[x].confirmedCount,\n        y: plotSpecificType === 'subregion_fatality' ? diseases[x].deadCount / diseases[x].confirmedCount : diseases[x].deadCount,\n        lang,\n        name: diseases[x][lang],\n        years: diseases[x].years,\n        noClick: true\n      }]\n    });\n  });\n  const {\n    logTickMin,\n    logTickMax\n  } = getLogTickValues(minValue, maxValue);\n  return {\n    plotData,\n    logTickMin,\n    logTickMax\n  };\n};\n\nconst generatePlotDataSubregion = ({\n  data,\n  date,\n  currentRegion,\n  lang,\n  darkMode,\n  playing,\n  scale,\n  metric,\n  plotSpecificType,\n  plotDetails,\n  plotDates,\n  fullPlot\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  let maxValue = 0;\n  let minValue = 100000;\n  const numOfRegions = !fullPlot ? 6 : 10;\n  const subregions = playing ? getSubregions(data, currentRegion, metric, numOfRegions) : getSubregions(data, currentRegion, metric, numOfRegions, date);\n  let plotData = subregions.map((region, i) => {\n    const counts = currentData[region][metric];\n    const id = lang === 'zh' ? region : currentData[region].ENGLISH;\n    return {\n      id: simplifyName(id, lang),\n      fullId: id,\n      name: region,\n      color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\n      data: Object.keys(counts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n        if (counts[d] > maxValue) maxValue = counts[d];\n        if (counts[d] < minValue) minValue = counts[d];\n        return scale === 'linear' || counts[d] > 0 ? {\n          x: d,\n          y: counts[d],\n          lang\n        } : null;\n      }).filter(x => x != null)\n    };\n  }).reverse();\n  if (plotSpecificType === 'subregion_new') plotData = convertTotalToNew(plotData);\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData,\n    ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue)\n  };\n};\n\nconst getCurrentData = (data, currentRegion) => {\n  const currentData = currentRegion.length === 1 && currentRegion[0] === str.GLOBAL_ZH ? data : getDataFromRegion(data, currentRegion);\n  return currentData;\n}; // convert cumulative dataset to daily increasement dataset\n\n\nconst convertTotalToNew = plotData => {\n  plotData.forEach(metricData => {\n    metricData.data = metricData.data.reduce((s, v, i) => [...s, metricData.data[i - 1] ? { ...v,\n      y: v.y - metricData.data[i - 1].y\n    } : v], []);\n  });\n  return plotData;\n}; // moving averages\n\n\nconst calcMovingAverage = (plotData, days) => {\n  if (days === '3d') {\n    plotData.forEach(metricData => {\n      metricData.data = metricData.data.reduce((s, v, i) => {\n        let newY = v.y;\n\n        if (metricData.data[i - 1] && metricData.data[i + 1]) {\n          newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3;\n        }\n\n        return [...s, { ...v,\n          y: newY\n        }];\n      }, []);\n    });\n  } else if (days === '5d') {\n    plotData.forEach(metricData => {\n      metricData.data = metricData.data.reduce((s, v, i) => {\n        let newY = v.y;\n\n        if (metricData.data[i - 1] && metricData.data[i - 2] && metricData.data[i + 1] && metricData.data[i + 2]) {\n          newY = (metricData.data[i - 2].y + metricData.data[i - 1].y + v.y + metricData.data[i + 1].y + metricData.data[i + 2].y) / 5;\n        } else if (metricData.data[i - 1] && metricData.data[i + 1]) {\n          newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3;\n        }\n\n        return [...s, { ...v,\n          y: newY\n        }];\n      }, []);\n    });\n  }\n\n  return plotData;\n}; // apply date range\n\n\nconst applyDateRange = (plotData, plotDates) => {\n  plotData.forEach(p => {\n    p.data = p.data.filter(x => parseDate(x.x) <= parseDate(plotDates[1]) && parseDate(x.x) >= parseDate(plotDates[0]));\n  });\n  return plotData;\n}; // data from top N subregions\n\n\nconst getSubregions = (data, currentRegion, metric = 'confirmedCount', topN = null, date = null) => {\n  const currentData = getCurrentData(data, currentRegion);\n  const subregions = Object.keys(currentData).filter(region => !['confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH].includes(region)).sort((a, b) => {\n    let aCounts = Math.max(...Object.values(currentData[a][metric]));\n    let bCounts = Math.max(...Object.values(currentData[b][metric]));\n\n    if (date != null) {\n      aCounts = currentData[a][metric][date] ? currentData[a][metric][date] : 0;\n      bCounts = currentData[b][metric][date] ? currentData[b][metric][date] : 0;\n    }\n\n    return aCounts <= bCounts ? 1 : -1;\n  }); // top affected subregions\n\n  return topN != null ? subregions.filter((region, i) => i <= topN - 1 && Math.max(...Object.values(currentData[region][metric])) !== 0) : subregions;\n};\n\nconst getLogTickValues = (minValue, maxValue) => {\n  const logTickMin = minValue <= maxValue ? Math.max(10 ** Math.floor(Math.log10(minValue)), 1) : 1;\n  const logTickMax = minValue <= maxValue ? Math.max(10 ** Math.ceil(Math.log10(maxValue)), 10) : 1;\n  const tickValues = [...Array(Math.log10(logTickMax / logTickMin) + 1).keys()].map(x => 10 ** x * logTickMin);\n  return {\n    tickValues,\n    logTickMin,\n    logTickMax\n  };\n};\n\nconst getTickValues = (scale, plotSpecificType, fullPlot, minValue, maxValue) => {\n  return scale === 'log' && plotSpecificTypes[plotSpecificType].log ? getLogTickValues(minValue, maxValue) : {\n    tickValues: fullPlot ? 10 : 5,\n    logTickMin: 1,\n    logTickMax: 1\n  };\n};\n\nconst generatePlotDataFunc = {\n  total: generatePlotDataTotal,\n  new: generatePlotDataNew,\n  growth_total: generatePlotDataGrowthRate,\n  growth_new: generatePlotDataGrowthRate,\n  fatality_recovery: generatePlotDataRate,\n  one_vs_rest: generatePlotDataOneVsRest,\n  one_vs_rest_new: generatePlotDataOneVsRest,\n  most_affected_subregions: generatePlotDataSubregionRankings,\n  most_affected_subregions_new: generatePlotDataSubregionRankings,\n  subregion_active_stream: generatePlotDataSubregionStream,\n  fatality_line: generatePlotDataFatalityLine,\n  fatality_line2: generatePlotDataFatalityLine,\n  fatality_line_only: generatePlotDataFatalityLine,\n  fatality_line2_only: generatePlotDataFatalityLine,\n  subregion_fatality: generatePlotDataSubregionFatality,\n  subregion_fatality2: generatePlotDataSubregionFatality,\n  subregion_fatality_only: generatePlotDataSubregionFatality,\n  subregion_fatality2_only: generatePlotDataSubregionFatality,\n  subregion_total: generatePlotDataSubregion,\n  subregion_new: generatePlotDataSubregion,\n  subregion_total_stream: generatePlotDataSubregionStream,\n  subregion_new_stream: generatePlotDataSubregionStream\n};","map":{"version":3,"sources":["D:/programming/react/new covid/covid19/src/utils/plot_data.js"],"names":["getDataFromRegion","metricText","parseDate","simplifyName","str","plotSpecificTypes","i18n","diseases","generatePlotData","params","generatePlotDataFunc","plotSpecificType","metricColors","confirmedCount","deadCount","curedCount","metricColorsDark","generatePlotDataTotal","data","date","currentRegion","lang","darkMode","playing","scale","plotDetails","plotDates","fullPlot","fullData","maxValue","minValue","plotData","map","metric","counts","id","color","Object","keys","sort","a","b","filter","d","x","y","calcMovingAverage","movingAverage","applyDateRange","getTickValues","generatePlotDataNew","convertTotalToNew","generatePlotDataGrowthRate","forEach","metricData","reduce","s","v","i","generatePlotDataRate","confirmedCounts","metrics","recoveryRate","newMetric","count","generatePlotDataOneVsRest","currentData","regionName","length","ENGLISH","parentRegion","GLOBAL_ZH","slice","parentData","parentCounts","parentRegionName","parentPlotData","REST","currentPlotData","push","generatePlotDataSubregionRankings","getCurrentData","subregions","getSubregions","regionIndices","dates","region","Set","dd","fullId","name","regionSkipped","regionCounts","generatePlotDataSubregionStream","sortBy","numOfRegions","subregionsData","plotKeys","OTHERS","reverse","subregionCounts","remainingConfirmed","Math","max","otherConfirmedCount","otherDeadCount","otherCuredCount","includes","confirmedCountPrevious","deadCountPrevious","curedCountPrevious","otherCount","generatePlotDataFatalityLine","cfr","years","generatePlotDataSubregionFatality","min","noClick","logTickMin","logTickMax","getLogTickValues","generatePlotDataSubregion","days","newY","p","topN","aCounts","values","bCounts","floor","log10","ceil","tickValues","Array","log","total","new","growth_total","growth_new","fatality_recovery","one_vs_rest","one_vs_rest_new","most_affected_subregions","most_affected_subregions_new","subregion_active_stream","fatality_line","fatality_line2","fatality_line_only","fatality_line2_only","subregion_fatality","subregion_fatality2","subregion_fatality_only","subregion_fatality2_only","subregion_total","subregion_new","subregion_total_stream","subregion_new_stream"],"mappings":"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","sourcesContent":["import { getDataFromRegion, metricText, parseDate, simplifyName } from './utils'\r\nimport * as str from './strings'\r\nimport { plotSpecificTypes } from './plot_types'\r\nimport i18n from '../data/i18n.yml'\r\nimport diseases from '../data/other_diseases_stats.yml'\r\n\r\nexport const generatePlotData = (params) => generatePlotDataFunc[params.plotSpecificType](params)\r\n\r\nconst metricColors = {\r\n    confirmedCount: 'var(--primary-color-4)',\r\n    deadCount: 'var(--primary-color-10)',\r\n    curedCount: 'var(--primary-color-2)'\r\n}\r\n\r\nconst metricColorsDark = {\r\n    confirmedCount: 'var(--primary-color-4)',\r\n    deadCount: 'var(--lighter-grey)',\r\n    curedCount: 'var(--primary-color-2)'\r\n}\r\n\r\nconst generatePlotDataTotal = (\r\n    { data, date, currentRegion, lang, darkMode, playing, scale, plotSpecificType, plotDetails, plotDates, fullPlot },\r\n    fullData = false\r\n) => {\r\n    let maxValue = 0\r\n    let minValue = 100000\r\n\r\n    let plotData = [ 'deadCount', 'curedCount', 'confirmedCount' ].map((metric) => {\r\n        const counts = getDataFromRegion(data, currentRegion)[metric]\r\n        return {\r\n            id: metricText[metric][lang],\r\n            color: darkMode ? metricColorsDark[metric] : metricColors[metric],\r\n            data: Object.keys(counts)\r\n                .sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\r\n                .filter((d) => !playing || parseDate(d) <= parseDate(date))\r\n                .map((d) => {\r\n                    if (counts[d] > maxValue) maxValue = counts[d]\r\n                    if (counts[d] < minValue) minValue = counts[d]\r\n\r\n                    return scale === 'linear' || counts[d] > 0\r\n                        ? {\r\n                              x: d,\r\n                              y: counts[d]\r\n                          }\r\n                        : null\r\n                })\r\n                .filter((x) => x != null)\r\n        }\r\n    })\r\n\r\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\r\n    if (!fullData) plotData = applyDateRange(plotData, plotDates)\r\n\r\n    return { plotData, ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue) }\r\n}\r\n\r\nconst generatePlotDataNew = (params, fullData = false) => {\r\n    let { plotData } = generatePlotDataTotal(params, true)\r\n\r\n    plotData = convertTotalToNew(plotData)\r\n    if (!fullData) plotData = applyDateRange(plotData, params.plotDates)\r\n\r\n    return { plotData }\r\n}\r\n\r\nconst generatePlotDataGrowthRate = (params) => {\r\n    let { plotData } =\r\n        params.plotSpecificType === 'growth_total'\r\n            ? generatePlotDataTotal(params, true)\r\n            : generatePlotDataNew(params, true)\r\n    const metric = params.metric\r\n\r\n    plotData.forEach((metricData) => {\r\n        metricData.data = metricData.data.reduce(\r\n            (s, v, i) => [\r\n                ...s,\r\n                metricData.data[i - 1] && metricData.data[i - 1].y > 0\r\n                    ? { ...v, y: (v.y - metricData.data[i - 1].y) / metricData.data[i - 1].y }\r\n                    : { ...v, y: 0 }\r\n            ],\r\n            []\r\n        )\r\n    })\r\n\r\n    if (metric === 'confirmedCount') plotData = [ plotData[2] ]\r\n    if (metric === 'curedCount') plotData = [ plotData[1] ]\r\n    if (metric === 'deadCount') plotData = [ plotData[0] ]\r\n\r\n    plotData = applyDateRange(plotData, params.plotDates)\r\n\r\n    return { plotData }\r\n}\r\n\r\nconst generatePlotDataRate = ({ data, currentRegion, darkMode, lang, date, playing, plotDetails, plotDates }) => {\r\n    const confirmedCounts = getDataFromRegion(data, currentRegion)['confirmedCount']\r\n\r\n    const metrics = plotDetails.recoveryRate === 'show' ? [ 'deadCount', 'curedCount' ] : [ 'deadCount' ]\r\n    let plotData = metrics.map((metric) => {\r\n        const counts = getDataFromRegion(data, currentRegion)[metric]\r\n        const newMetric = metric === 'deadCount' ? 'fatalityRate' : 'recoveryRate'\r\n        return {\r\n            id: metricText[newMetric][lang],\r\n            color: darkMode ? metricColorsDark[metric] : metricColors[metric],\r\n            data: Object.keys(counts)\r\n                .filter((d) => !playing || parseDate(d) <= parseDate(date))\r\n                .map((d) => ({ d, count: confirmedCounts[d] > 0 ? counts[d] / confirmedCounts[d] : 0 }))\r\n                .map(({ d, count }) => {\r\n                    return {\r\n                        x: d,\r\n                        y: count\r\n                    }\r\n                })\r\n        }\r\n    })\r\n\r\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\r\n    plotData = applyDateRange(plotData, plotDates)\r\n\r\n    return { plotData }\r\n}\r\n\r\nconst generatePlotDataOneVsRest = ({\r\n    data,\r\n    currentRegion,\r\n    metric,\r\n    lang,\r\n    date,\r\n    playing,\r\n    scale,\r\n    plotSpecificType,\r\n    plotDetails,\r\n    plotDates,\r\n    fullPlot\r\n}) => {\r\n    let maxValue = 0\r\n    let minValue = 100000\r\n\r\n    const currentData = getDataFromRegion(data, currentRegion)\r\n    const counts = currentData[metric]\r\n    let regionName = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH\r\n    regionName = simplifyName(regionName, lang)\r\n\r\n    const parentRegion =\r\n        currentRegion.length === 1 ? [ str.GLOBAL_ZH ] : currentRegion.slice(0, currentRegion.length - 1)\r\n    const parentData = getDataFromRegion(data, parentRegion)\r\n    const parentCounts = parentData[metric]\r\n    let parentRegionName = lang === 'zh' ? parentRegion[parentRegion.length - 1] : parentData.ENGLISH\r\n    parentRegionName = simplifyName(parentRegionName, lang)\r\n\r\n    let plotData = []\r\n\r\n    const parentPlotData = {\r\n        id: lang === 'zh' ? `${parentRegionName} (${i18n.REST[lang]})` : `${i18n.REST[lang]} of ${parentRegionName}`,\r\n        color: 'var(--primary-color-4)',\r\n        data: Object.keys(parentCounts)\r\n            .filter((d) => !playing || parseDate(d) <= parseDate(date))\r\n            .map((d) => {\r\n                if (counts[d] == null) return null\r\n\r\n                if (parentCounts[d] - counts[d] > maxValue) maxValue = parentCounts[d] - counts[d]\r\n                if (parentCounts[d] - counts[d] < minValue) minValue = parentCounts[d] - counts[d]\r\n\r\n                return scale === 'linear' || parentCounts[d] - counts[d] > 0\r\n                    ? {\r\n                          x: d,\r\n                          y: parentCounts[d] - counts[d]\r\n                      }\r\n                    : null\r\n            })\r\n            .filter((x) => x != null)\r\n    }\r\n\r\n    const currentPlotData = {\r\n        id: regionName,\r\n        color: 'var(--primary-color-2)',\r\n        data: Object.keys(counts)\r\n            .filter((d) => !playing || parseDate(d) <= parseDate(date))\r\n            .map((d) => {\r\n                if (parentCounts[d] == null) return null\r\n\r\n                if (counts[d] > maxValue) maxValue = counts[d]\r\n                if (counts[d] < minValue) minValue = counts[d]\r\n\r\n                return scale === 'linear' || counts[d] > 0\r\n                    ? {\r\n                          x: d,\r\n                          y: counts[d]\r\n                      }\r\n                    : null\r\n            })\r\n            .filter((x) => x != null)\r\n    }\r\n\r\n    plotData.push(parentPlotData)\r\n    plotData.push(currentPlotData)\r\n    if (plotSpecificType === 'one_vs_rest_new') {\r\n        plotData = convertTotalToNew(plotData)\r\n    }\r\n\r\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\r\n    plotData = applyDateRange(plotData, plotDates)\r\n\r\n    return { plotData, ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue) }\r\n}\r\n\r\nconst generatePlotDataSubregionRankings = ({\r\n    data,\r\n    currentRegion,\r\n    metric,\r\n    lang,\r\n    darkMode,\r\n    playing,\r\n    date,\r\n    plotDates,\r\n    plotSpecificType\r\n}) => {\r\n    const currentData = getCurrentData(data, currentRegion)\r\n    const subregions = playing\r\n        ? getSubregions(data, currentRegion, metric, 10)\r\n        : getSubregions(data, currentRegion, metric, 10, date)\r\n\r\n    let regionIndices = {}\r\n    let dates = []\r\n\r\n    let plotData = subregions\r\n        .map((region, i) => {\r\n            dates = [ ...dates, ...Object.keys(currentData[region][metric]) ]\r\n            dates = [ ...new Set(dates) ]\r\n            regionIndices[region] = i\r\n            return region\r\n        })\r\n        .map((region, i) => {\r\n            const id = lang === 'zh' ? region : currentData[region].ENGLISH\r\n            const dd = Object.keys(currentData[region][metric])\r\n                .sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\r\n                .filter((d) => parseDate(d) <= parseDate(date))\r\n                .filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\r\n            const counts = dd.map((d) => currentData[region][metric][d])\r\n            let count = counts[counts.length - 1]\r\n            if (plotSpecificType === 'most_affected_subregions_new')\r\n                count =\r\n                    counts.length >= 2\r\n                        ? counts[counts.length - 1] - counts[counts.length - 2]\r\n                        : counts[counts.length - 1]\r\n            return {\r\n                id: simplifyName(id, lang),\r\n                fullId: id,\r\n                name: region,\r\n                color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\r\n                count,\r\n                data: []\r\n            }\r\n        })\r\n\r\n    dates = dates.sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\r\n\r\n    let regionSkipped = {}\r\n    dates\r\n        .filter((d) => parseDate(d) <= parseDate(date))\r\n        .filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\r\n        .forEach((d, i) => {\r\n            let regionCounts = []\r\n            plotData.forEach((region) => {\r\n                let counts = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0\r\n                if (plotSpecificType === 'most_affected_subregions_new') {\r\n                    if (i > 0 && currentData[region.name][metric][dates[i - 1]])\r\n                        counts = counts - currentData[region.name][metric][dates[i - 1]]\r\n                }\r\n                regionCounts.push({\r\n                    region: region.name,\r\n                    counts\r\n                })\r\n            })\r\n            regionCounts = regionCounts.sort((a, b) => (a.counts <= b.counts ? 1 : -1))\r\n\r\n            regionCounts.forEach((region, i) => {\r\n                if (region.counts === 0 && regionSkipped[region.region] == null) {\r\n                    plotData[regionIndices[region.region]].data.push({\r\n                        x: d,\r\n                        y: null\r\n                    })\r\n                } else {\r\n                    regionSkipped[region.region] = true\r\n                    plotData[regionIndices[region.region]].data.push({\r\n                        x: d,\r\n                        y: i + 1\r\n                    })\r\n                }\r\n            })\r\n        })\r\n\r\n    return { plotData, dates }\r\n}\r\n\r\nconst generatePlotDataSubregionStream = ({\r\n    data,\r\n    currentRegion,\r\n    lang,\r\n    playing,\r\n    date,\r\n    plotDates,\r\n    metric,\r\n    plotSpecificType,\r\n    fullPlot\r\n}) => {\r\n    const currentData = getCurrentData(data, currentRegion)\r\n    let dates = []\r\n    let plotData = []\r\n\r\n    const sortBy = plotSpecificType === 'subregion_active_stream' ? 'confirmedCount' : metric\r\n    const numOfRegions = !fullPlot ? 5 : 9\r\n    let subregionsData = getSubregions(data, currentRegion, sortBy, numOfRegions)\r\n        .map((region) => {\r\n            dates = [ ...dates, ...Object.keys(currentData[region]['confirmedCount']) ]\r\n            dates = [ ...new Set(dates) ]\r\n            return region\r\n        })\r\n        .map((region) => {\r\n            const id = lang === 'zh' ? region : currentData[region].ENGLISH\r\n            return {\r\n                id: simplifyName(id, lang),\r\n                fullId: id,\r\n                name: region\r\n            }\r\n        })\r\n\r\n    let plotKeys = subregionsData.map((x) => x.id)\r\n\r\n    // at least (numOfRegions + 1) subregions\r\n    if (Object.keys(currentData).length >= numOfRegions + 5) plotKeys = [ ...plotKeys, i18n.OTHERS[lang] ]\r\n    plotKeys = plotKeys.reverse()\r\n\r\n    dates = dates.sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\r\n    dates = dates.filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\r\n\r\n    // no subregions\r\n    if (subregionsData.length === 0) {\r\n        dates = Object.keys(currentData['confirmedCount']).sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\r\n        let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH\r\n        id = simplifyName(id, lang)\r\n        plotKeys = [ id ]\r\n    }\r\n\r\n    dates.filter((d) => !playing || parseDate(d) <= parseDate(date)).forEach((d, i) => {\r\n        let subregionCounts = {}\r\n        subregionsData.forEach((region) => {\r\n            if (plotSpecificType === 'subregion_active_stream') {\r\n                const confirmedCount = currentData[region.name]['confirmedCount'][d]\r\n                    ? currentData[region.name]['confirmedCount'][d]\r\n                    : 0\r\n                const deadCount = currentData[region.name]['deadCount'][d]\r\n                    ? currentData[region.name]['deadCount'][d]\r\n                    : 0\r\n                const curedCount = currentData[region.name]['curedCount'][d]\r\n                    ? currentData[region.name]['curedCount'][d]\r\n                    : 0\r\n                const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0)\r\n                subregionCounts[region.id] = remainingConfirmed\r\n            } else {\r\n                let count = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0\r\n                if (plotSpecificType === 'subregion_new_stream' && currentData[region.name][metric][dates[i - 1]])\r\n                    count -= currentData[region.name][metric][dates[i - 1]]\r\n                subregionCounts[region.id] = count\r\n            }\r\n        })\r\n\r\n        let otherConfirmedCount = 0\r\n        let otherDeadCount = 0\r\n        let otherCuredCount = 0\r\n\r\n        // compute number of remaining confirmed cases from non-top-5 subregions\r\n        Object.keys(currentData)\r\n            .filter(\r\n                (region) => ![ 'confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH ].includes(region)\r\n            )\r\n            .filter((region) => !subregionsData.map((x) => x.name).includes(region))\r\n            .forEach((region) => {\r\n                const confirmedCount = currentData[region]['confirmedCount'][d]\r\n                    ? currentData[region]['confirmedCount'][d]\r\n                    : 0\r\n                const deadCount = currentData[region]['deadCount'][d] ? currentData[region]['deadCount'][d] : 0\r\n                const curedCount = currentData[region]['curedCount'][d] ? currentData[region]['curedCount'][d] : 0\r\n                otherConfirmedCount += confirmedCount\r\n                otherDeadCount += deadCount\r\n                otherCuredCount += curedCount\r\n                if (plotSpecificType === 'subregion_new_stream') {\r\n                    const confirmedCountPrevious = currentData[region]['confirmedCount'][dates[i - 1]]\r\n                        ? currentData[region]['confirmedCount'][dates[i - 1]]\r\n                        : 0\r\n                    const deadCountPrevious = currentData[region]['deadCount'][dates[i - 1]]\r\n                        ? currentData[region]['deadCount'][dates[i - 1]]\r\n                        : 0\r\n                    const curedCountPrevious = currentData[region]['curedCount'][dates[i - 1]]\r\n                        ? currentData[region]['curedCount'][dates[i - 1]]\r\n                        : 0\r\n                    otherConfirmedCount -= confirmedCountPrevious\r\n                    otherDeadCount -= deadCountPrevious\r\n                    otherCuredCount -= curedCountPrevious\r\n                }\r\n            })\r\n        let otherCount = 0\r\n        if (metric === 'confirmedCount') otherCount = Math.max(otherConfirmedCount, 0)\r\n        if (metric === 'deadCount') otherCount = Math.max(otherDeadCount, 0)\r\n        if (metric === 'curedCount') otherCount = Math.max(otherCuredCount, 0)\r\n        if (plotSpecificType === 'subregion_active_stream')\r\n            otherCount = Math.max(otherConfirmedCount - otherDeadCount - otherCuredCount, 0)\r\n\r\n        if (Object.keys(currentData).length >= 10) subregionCounts[i18n.OTHERS[lang]] = otherCount\r\n\r\n        // no subregions\r\n        if (subregionsData.length === 0) {\r\n            const confirmedCount = currentData['confirmedCount'][d] ? currentData['confirmedCount'][d] : 0\r\n            const deadCount = currentData['deadCount'][d] ? currentData['deadCount'][d] : 0\r\n            const curedCount = currentData['curedCount'][d] ? currentData['curedCount'][d] : 0\r\n            const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0)\r\n            let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH\r\n            id = simplifyName(id, lang)\r\n            subregionCounts[id] =\r\n                plotSpecificType === 'subregion_active_stream'\r\n                    ? remainingConfirmed\r\n                    : Math.max(currentData[metric][d] ? currentData[metric][d] : 0, 0)\r\n        }\r\n        plotData.push(subregionCounts)\r\n    })\r\n    return { plotData, dates, plotKeys }\r\n}\r\n\r\nconst generatePlotDataFatalityLine = ({ data, currentRegion, date, darkMode, lang, plotSpecificType, plotDates }) => {\r\n    const confirmedCount = getDataFromRegion(data, currentRegion)['confirmedCount']\r\n    const deadCount = getDataFromRegion(data, currentRegion)['deadCount']\r\n    const plotData = [\r\n        {\r\n            id: 'fatality-line',\r\n            color: darkMode ? 'var(--primary-color-2)' : 'var(--primary-color-5)',\r\n            data: Object.keys(confirmedCount)\r\n                .filter(\r\n                    (d) =>\r\n                        parseDate(d) <= parseDate(date) &&\r\n                        confirmedCount[d] > 0 &&\r\n                        (deadCount[d] > 0 ||\r\n                            plotSpecificType === 'fatality_line' ||\r\n                            plotSpecificType === 'fatality_line_only')\r\n                )\r\n                .filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\r\n                .map((d) => ({ d, cfr: deadCount[d] != null ? deadCount[d] / confirmedCount[d] : 0 }))\r\n                .map(({ d, cfr }) => {\r\n                    return {\r\n                        x: confirmedCount[d],\r\n                        y:\r\n                            plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line_only'\r\n                                ? cfr\r\n                                : deadCount[d],\r\n                        date: d,\r\n                        lang\r\n                    }\r\n                })\r\n        }\r\n    ]\r\n    if (plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line2')\r\n        Object.keys(diseases).forEach((x) => {\r\n            plotData.push({\r\n                id: x,\r\n                color: 'var(--light-grey)',\r\n                data: [\r\n                    {\r\n                        x: diseases[x].confirmedCount,\r\n                        y:\r\n                            plotSpecificType === 'fatality_line'\r\n                                ? diseases[x].deadCount / diseases[x].confirmedCount\r\n                                : diseases[x].deadCount,\r\n                        lang,\r\n                        name: diseases[x][lang],\r\n                        years: diseases[x].years\r\n                    }\r\n                ]\r\n            })\r\n        })\r\n    return { plotData }\r\n}\r\n\r\nconst generatePlotDataSubregionFatality = ({ data, currentRegion, date, lang, darkMode, plotSpecificType }) => {\r\n    const currentData = getCurrentData(data, currentRegion)\r\n    let plotData = []\r\n    let maxValue = 0\r\n    let minValue = 100000\r\n\r\n    getSubregions(data, currentRegion)\r\n        .reverse()\r\n        .filter(\r\n            (region) =>\r\n                currentData[region]['confirmedCount'][date] > 0 &&\r\n                currentData[region]['deadCount'][date] >= 0 &&\r\n                (currentData[region]['deadCount'][date] > 0 ||\r\n                    plotSpecificType === 'subregion_fatality' ||\r\n                    plotSpecificType === 'subregion_fatality_only')\r\n        )\r\n        .forEach((region, i) => {\r\n            const confirmedCount = currentData[region].confirmedCount[date]\r\n            const deadCount = currentData[region].deadCount[date]\r\n            maxValue = Math.max(maxValue, confirmedCount)\r\n            minValue = Math.min(minValue, confirmedCount)\r\n\r\n            plotData.push({\r\n                id: region,\r\n                color: darkMode ? 'rgba(222,73,104,0.6)' : 'rgba(183,55,121,0.5)',\r\n                data: [\r\n                    {\r\n                        x: confirmedCount,\r\n                        y:\r\n                            plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality_only'\r\n                                ? deadCount / confirmedCount\r\n                                : deadCount,\r\n                        regionName: lang === 'zh' ? region : currentData[region].ENGLISH,\r\n                        lang\r\n                    }\r\n                ]\r\n            })\r\n        })\r\n\r\n    if (plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality2')\r\n        Object.keys(diseases).forEach((x) => {\r\n            plotData.push({\r\n                id: x,\r\n                color: 'rgba(0,0,0,0)',\r\n                data: [\r\n                    {\r\n                        x: diseases[x].confirmedCount,\r\n                        y:\r\n                            plotSpecificType === 'subregion_fatality'\r\n                                ? diseases[x].deadCount / diseases[x].confirmedCount\r\n                                : diseases[x].deadCount,\r\n                        lang,\r\n                        name: diseases[x][lang],\r\n                        years: diseases[x].years,\r\n                        noClick: true\r\n                    }\r\n                ]\r\n            })\r\n        })\r\n\r\n    const { logTickMin, logTickMax } = getLogTickValues(minValue, maxValue)\r\n\r\n    return { plotData, logTickMin, logTickMax }\r\n}\r\n\r\nconst generatePlotDataSubregion = ({\r\n    data,\r\n    date,\r\n    currentRegion,\r\n    lang,\r\n    darkMode,\r\n    playing,\r\n    scale,\r\n    metric,\r\n    plotSpecificType,\r\n    plotDetails,\r\n    plotDates,\r\n    fullPlot\r\n}) => {\r\n    const currentData = getCurrentData(data, currentRegion)\r\n    let maxValue = 0\r\n    let minValue = 100000\r\n\r\n    const numOfRegions = !fullPlot ? 6 : 10\r\n    const subregions = playing\r\n        ? getSubregions(data, currentRegion, metric, numOfRegions)\r\n        : getSubregions(data, currentRegion, metric, numOfRegions, date)\r\n\r\n    let plotData = subregions\r\n        .map((region, i) => {\r\n            const counts = currentData[region][metric]\r\n            const id = lang === 'zh' ? region : currentData[region].ENGLISH\r\n            return {\r\n                id: simplifyName(id, lang),\r\n                fullId: id,\r\n                name: region,\r\n                color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\r\n                data: Object.keys(counts)\r\n                    .filter((d) => !playing || parseDate(d) <= parseDate(date))\r\n                    .map((d) => {\r\n                        if (counts[d] > maxValue) maxValue = counts[d]\r\n                        if (counts[d] < minValue) minValue = counts[d]\r\n\r\n                        return scale === 'linear' || counts[d] > 0\r\n                            ? {\r\n                                  x: d,\r\n                                  y: counts[d],\r\n                                  lang\r\n                              }\r\n                            : null\r\n                    })\r\n                    .filter((x) => x != null)\r\n            }\r\n        })\r\n        .reverse()\r\n\r\n    if (plotSpecificType === 'subregion_new') plotData = convertTotalToNew(plotData)\r\n\r\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\r\n    plotData = applyDateRange(plotData, plotDates)\r\n\r\n    return { plotData, ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue) }\r\n}\r\n\r\nconst getCurrentData = (data, currentRegion) => {\r\n    const currentData =\r\n        currentRegion.length === 1 && currentRegion[0] === str.GLOBAL_ZH ? data : getDataFromRegion(data, currentRegion)\r\n\r\n    return currentData\r\n}\r\n\r\n// convert cumulative dataset to daily increasement dataset\r\nconst convertTotalToNew = (plotData) => {\r\n    plotData.forEach((metricData) => {\r\n        metricData.data = metricData.data.reduce(\r\n            (s, v, i) => [ ...s, metricData.data[i - 1] ? { ...v, y: v.y - metricData.data[i - 1].y } : v ],\r\n            []\r\n        )\r\n    })\r\n\r\n    return plotData\r\n}\r\n\r\n// moving averages\r\nconst calcMovingAverage = (plotData, days) => {\r\n    if (days === '3d') {\r\n        plotData.forEach((metricData) => {\r\n            metricData.data = metricData.data.reduce((s, v, i) => {\r\n                let newY = v.y\r\n                if (metricData.data[i - 1] && metricData.data[i + 1]) {\r\n                    newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3\r\n                }\r\n                return [ ...s, { ...v, y: newY } ]\r\n            }, [])\r\n        })\r\n    } else if (days === '5d') {\r\n        plotData.forEach((metricData) => {\r\n            metricData.data = metricData.data.reduce((s, v, i) => {\r\n                let newY = v.y\r\n                if (\r\n                    metricData.data[i - 1] &&\r\n                    metricData.data[i - 2] &&\r\n                    metricData.data[i + 1] &&\r\n                    metricData.data[i + 2]\r\n                ) {\r\n                    newY =\r\n                        (metricData.data[i - 2].y +\r\n                            metricData.data[i - 1].y +\r\n                            v.y +\r\n                            metricData.data[i + 1].y +\r\n                            metricData.data[i + 2].y) /\r\n                        5\r\n                } else if (metricData.data[i - 1] && metricData.data[i + 1]) {\r\n                    newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3\r\n                }\r\n                return [ ...s, { ...v, y: newY } ]\r\n            }, [])\r\n        })\r\n    }\r\n\r\n    return plotData\r\n}\r\n\r\n// apply date range\r\nconst applyDateRange = (plotData, plotDates) => {\r\n    plotData.forEach((p) => {\r\n        p.data = p.data.filter(\r\n            (x) => parseDate(x.x) <= parseDate(plotDates[1]) && parseDate(x.x) >= parseDate(plotDates[0])\r\n        )\r\n    })\r\n\r\n    return plotData\r\n}\r\n\r\n// data from top N subregions\r\nconst getSubregions = (data, currentRegion, metric = 'confirmedCount', topN = null, date = null) => {\r\n    const currentData = getCurrentData(data, currentRegion)\r\n\r\n    const subregions = Object.keys(currentData)\r\n        .filter((region) => ![ 'confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH ].includes(region))\r\n        .sort((a, b) => {\r\n            let aCounts = Math.max(...Object.values(currentData[a][metric]))\r\n            let bCounts = Math.max(...Object.values(currentData[b][metric]))\r\n            if (date != null) {\r\n                aCounts = currentData[a][metric][date] ? currentData[a][metric][date] : 0\r\n                bCounts = currentData[b][metric][date] ? currentData[b][metric][date] : 0\r\n            }\r\n\r\n            return aCounts <= bCounts ? 1 : -1\r\n        })\r\n\r\n    // top affected subregions\r\n    return topN != null\r\n        ? subregions.filter(\r\n              (region, i) => i <= topN - 1 && Math.max(...Object.values(currentData[region][metric])) !== 0\r\n          )\r\n        : subregions\r\n}\r\n\r\nconst getLogTickValues = (minValue, maxValue) => {\r\n    const logTickMin = minValue <= maxValue ? Math.max(10 ** Math.floor(Math.log10(minValue)), 1) : 1\r\n    const logTickMax = minValue <= maxValue ? Math.max(10 ** Math.ceil(Math.log10(maxValue)), 10) : 1\r\n    const tickValues = [ ...Array(Math.log10(logTickMax / logTickMin) + 1).keys() ].map((x) => 10 ** x * logTickMin)\r\n\r\n    return { tickValues, logTickMin, logTickMax }\r\n}\r\n\r\nconst getTickValues = (scale, plotSpecificType, fullPlot, minValue, maxValue) => {\r\n    return scale === 'log' && plotSpecificTypes[plotSpecificType].log\r\n        ? getLogTickValues(minValue, maxValue)\r\n        : { tickValues: fullPlot ? 10 : 5, logTickMin: 1, logTickMax: 1 }\r\n}\r\n\r\nconst generatePlotDataFunc = {\r\n    total: generatePlotDataTotal,\r\n    new: generatePlotDataNew,\r\n    growth_total: generatePlotDataGrowthRate,\r\n    growth_new: generatePlotDataGrowthRate,\r\n    fatality_recovery: generatePlotDataRate,\r\n    one_vs_rest: generatePlotDataOneVsRest,\r\n    one_vs_rest_new: generatePlotDataOneVsRest,\r\n    most_affected_subregions: generatePlotDataSubregionRankings,\r\n    most_affected_subregions_new: generatePlotDataSubregionRankings,\r\n    subregion_active_stream: generatePlotDataSubregionStream,\r\n    fatality_line: generatePlotDataFatalityLine,\r\n    fatality_line2: generatePlotDataFatalityLine,\r\n    fatality_line_only: generatePlotDataFatalityLine,\r\n    fatality_line2_only: generatePlotDataFatalityLine,\r\n    subregion_fatality: generatePlotDataSubregionFatality,\r\n    subregion_fatality2: generatePlotDataSubregionFatality,\r\n    subregion_fatality_only: generatePlotDataSubregionFatality,\r\n    subregion_fatality2_only: generatePlotDataSubregionFatality,\r\n    subregion_total: generatePlotDataSubregion,\r\n    subregion_new: generatePlotDataSubregion,\r\n    subregion_total_stream: generatePlotDataSubregionStream,\r\n    subregion_new_stream: generatePlotDataSubregionStream\r\n}\r\n"]},"metadata":{},"sourceType":"module"}